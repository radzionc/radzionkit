---
description: USE attempt utility WHEN handling errors is necessary FOR user feedback or alternative logic, NOT for logging
globs: *.ts,*.tsx
alwaysApply: false
---

# Use attempt Utility Instead of try-catch

## Core Rule

- **NEVER use try-catch blocks** for error handling
- **ONLY use `attempt`** from `@lib/utils/attempt` when you need to:
  - Show errors to users
  - Execute alternative logic on failure
  - Provide fallback values
- **Let errors bubble up naturally** - don't wrap functions just to log errors

## When to Use attempt

<example>
// ✅ Show error to user
const result = await attempt(() => saveUserData(data))
if ('data' in result) {
  showSuccessMessage()
} else {
  showErrorToUser(result.error.message)
}

// ✅ Alternative logic on failure
const primaryResult = await attempt(() => fetchPrimary())
const data = 'data' in primaryResult ? primaryResult.data : await fetchBackup()

// ✅ Fallback values
const prefs = withFallback(attempt(() => parsePrefs()), DEFAULT_PREFS)
</example>

## When NOT to Use attempt

<example type="invalid">
// ❌ Don't wrap just to log
await trackAnalytics(event) // Let it throw naturally

// ❌ Never use try-catch
try {
await fetchData()
} catch (error) {
console.error(error) // Just logging - let it throw
}

// ❌ Don't wrap internal utilities
await internalUtility() // Should throw on failure
</example>
