---
description: USE attempt utility WHEN handling errors INSTEAD OF try-catch blocks TO ensure consistent error handling
globs: *.{ts,tsx,js,jsx}
alwaysApply: false
---
 
# Use attempt Utility Instead of try-catch

## Context
- Applies when handling errors in asynchronous or synchronous operations
- The codebase provides a utility function `attempt` in `lib/utils/attempt.ts`
- This utility provides a consistent way to handle errors with Result types

## Requirements
- Always use the `attempt` utility instead of try-catch blocks
- Return and handle Result objects with `data` and `error` properties
- Use `withFallback` when a default value is needed in case of error

## Examples
<example>
// Good: Using attempt utility for error handling
import { attempt } from '@lib/utils/attempt'

// For synchronous functions
const result = attempt(() => parseJSON(data))
if ('data' in result) {
  // Handle success case
  processData(result.data)
} else {
  // Handle error case
  logError(result.error)
}

// For asynchronous functions
const result = await attempt(() => fetchData())
if ('data' in result) {
  // Handle success case
  processData(result.data)
} else {
  // Handle error case
  logError(result.error)
}

// Using withFallback for default values
const data = withFallback(attempt(() => parseJSON(data)), defaultValue)
</example>

<example type="invalid">
// Bad: Using try-catch directly
try {
  const data = parseJSON(data)
  processData(data)
} catch (error) {
  logError(error)
}

// Bad: Using try-catch with async/await
try {
  const data = await fetchData()
  processData(data)
} catch (error) {
  logError(error)
}
</example>